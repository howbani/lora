using LORA.Modules;
using LORA.Parameters;
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace LORA.DataPacket
{
    /// <summary>
    /// Interaction logic for Datapacket.xaml
    /// </summary>
    public partial class Datapacket : UserControl
    {
        public bool IsDelivered { get; set; }
        public int MaxHops { get; set; } // The maximum allowed hops.// this will be defined by the source node.
        public long PacektSequentID { get; set; }
        public double Delay { get; set; }
        public double UsedEnergy_Joule { get; set; }// the aucla consumed Energy
        public int Hops { get; set; } // the hops from the source to the sink.
        public int SourceNodeID { set; get; } 
        public Sensor SourceNode { get; set; } 
        public string Path { set; get; }
        public double RoutingDistance { set; get; }// The Routing Distance, denoted by〖 d〗_j^i (p_k ), of a data packet p_k traveled in the path P_j^i (p_k ) is the sum of distances between any two consecutive nodes in〖 P〗_j^i (p_k ) as modeled in (1). 
        public double DistanceFromSourceToSink { set; get; }
        public double RoutingZoneWidthCnt { get; set; }  

        public double PrepDistanceDistCnt { set; get; }
        public double TransDistanceDistCnt { set; get; }
        public double EnergyDistCnt { set; get; }
        public double DirectionDistCnt { set; get; }

       
        public double ForwardingRandomNumber { get; set; } // the random number generated by the forward node.

        public bool IsRandomControls { get; set; } // when ever to generate random controls.
         
        /// <summary>
        /// the prob of path. muliply for each hop.
        /// </summary>
        public double PathLinksQualityEstimator { get; set; }
        public int PacketWaitingTimes { get; set; } // when the sender's FS=null, That is all the numbers are in sleep. then we count it.

        public Datapacket()
        {

        }

        

        public Datapacket(Sensor sender, Sensor reciver)
        {
            try
            {
                InitializeComponent();
                Edg_start_point.StartPoint = sender.CenterLocation;
                Edg_end_point.Point = reciver.CenterLocation;
               
            }
            catch(Exception exp)
            {
                MessageBox.Show(exp.Message);
            }
        }

        public void cAnimate()
        {
          

        }

        private void lbl_lable_node_MouseEnter(object sender, MouseEventArgs e)
        {

        }

        /// <summary>
        /// RoutingDistanceEfficiency
        /// </summary>
        public double RoutingDistanceEfficiency
        {
            get
            {
                return 100 * (DistanceFromSourceToSink / RoutingDistance);
            }
        }

        
       
        /// <summary>
        /// Average Transmission Distance (ATD): for〖 P〗_b^s (g_k ), we define average transmission distance per hop as shown in (28).
        /// </summary>
        public double AverageTransDistrancePerHop
        {
            get
            {
                return (RoutingDistance / Hops);
            }
        }

         
        public double TransDistanceEfficiency
        {
            get
            {
                return 100 * (1 - (RoutingDistance / (PublicParamerters.SensingRangeRadius * Hops * (Hops + 1))));
            }
        }

        /// <summary>
        /// RoutingEfficiency
        /// </summary>
        public double RoutingEfficiency
        {
            get
            {
                return (RoutingDistanceEfficiency + TransDistanceEfficiency) / 2;
            }
        }

       
    }
}
